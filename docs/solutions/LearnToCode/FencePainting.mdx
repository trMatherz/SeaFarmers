import React from 'react';
import '../../../src/css/TopicPage.module.css';   
import Sidebar from '../../../src/components/Sidebar';   
import remarkMath from 'remark-math';
import rehypeKatex from 'rehype-katex';
import 'katex/dist/katex.min.css';
import { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';
import { okaidia } from 'react-syntax-highlighter/dist/esm/styles/prism';


export const moduleId = "LearnToCode"; 

<Sidebar moduleId={moduleId} /> 

# Fence Painting Solution

Tags: Input and Output

# Soluiton $1$: Case Work

There are $2$ cases: 

$1$ There are two segments

$2$ There is one long segment

This runs in $\mathcal{O}(1)$

# Case Work Implementation

<div style={{ transform: 'translateX(150px)' }}>
  <SyntaxHighlighter language="cpp" style={okaidia}>
{`#include <cmath>
#include <cstdio>
#include <vector>
#include <fstream>
std::ifstream cin ("paint.in");
std::ofstream cout ("paint.out");
#include <algorithm>
using namespace std;


int main() {
    int a, b, c, d; 
    cin >> a >> b >> c >> d; 
    if(b <= c || d <= a) cout << (d - c) + (b - a); // If two segments
    else { // If one segment
        int mx = b; 
        if(d > b) mx = d; 
        int mi = a; 
        if(c < mi) mi = c; 
        cout << mx - mi; 
    }
}
`}
  </SyntaxHighlighter>
</div>

# Soluiton $2$: Iterative Approach

Since $R$, the range of the coordinates is low, we can check each interval. 

This runs in $\mathcal{O}(R)$

# Case Work Implementation

<div style={{ transform: 'translateX(150px)' }}>
  <SyntaxHighlighter language="cpp" style={okaidia}>
{`#include <cmath>
#include <cstdio>
#include <vector>
#include <fstream>
std::ifstream cin ("paint.in");
std::ofstream cout ("paint.out");
#include <algorithm>
using namespace std;


int main() {
    int a, b, c, d; 
    cin >> a >> b >> c >> d; 
    int an = 0; 
    for(int i = 0; i < 100; i++) 
        if((i >= a && i < b) || (i >= c && i < d)) // If I is on either segment
            an++; 
    cout << an; 
}
`}
  </SyntaxHighlighter>
</div>

# Soluiton $3$: Generic Formula

We can further simplify the Solution $1$ to be a one line formula. We find the distance between the end points 
then subtract any over-counting. 

This runs in $\mathcal{O}(1)$

# Case Work Implementation

<div style={{ transform: 'translateX(150px)' }}>
  <SyntaxHighlighter language="cpp" style={okaidia}>
{`#include <cmath>
#include <cstdio>
#include <vector>
#include <fstream>
std::ifstream cin ("paint.in");
std::ofstream cout ("paint.out");
#include <algorithm>
using namespace std;


int main() {
    int a, b, c, d; 
    cin >> a >> b >> c >> d; 
    cout << max(b, d) - min(a, c) - max(c - b, 0) - max(a - d, 0); 
}
`}
  </SyntaxHighlighter>
</div>
