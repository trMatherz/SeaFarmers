"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7433],{62329:(n,e,s)=>{s.r(e),s.d(e,{assets:()=>m,contentTitle:()=>d,default:()=>g,frontMatter:()=>l,metadata:()=>t,moduleId:()=>h,toc:()=>u});const t=JSON.parse('{"id":"solutions/Novice/CreatingStrings","title":"CreatingStrings","description":"Tags: Sets, Recursion","source":"@site/docs/solutions/Novice/CreatingStrings.mdx","sourceDirName":"solutions/Novice","slug":"/solutions/Novice/CreatingStrings","permalink":"/SeaFarmers/docs/solutions/Novice/CreatingStrings","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"ChessboardAndQueens","permalink":"/SeaFarmers/docs/solutions/Novice/ChessboardAndQueens"},"next":{"title":"DistinctNumbers","permalink":"/SeaFarmers/docs/solutions/Novice/DistinctNumbers"}}');var i=s(74848),a=s(28453),r=(s(96540),s(42407),s(28092)),c=s(38866),o=s(40426);const l={},d="Creating Strings Solution",m={},h="Novice",u=[];function p(n){const e={annotation:"annotation",h1:"h1",header:"header",math:"math",mi:"mi",mo:"mo",mrow:"mrow",p:"p",semantics:"semantics",span:"span",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.A,{moduleId:h}),"\n",(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"creating-strings-solution",children:"Creating Strings Solution"})}),"\n",(0,i.jsx)(e.p,{children:"Tags: Sets, Recursion"}),"\n",(0,i.jsx)(e.h1,{id:"breakdown",children:"Breakdown"}),"\n",(0,i.jsx)(e.p,{children:"We can use recursion to generate all possible strings and store them in a set. They will already be sorted, so simply\niterate through the set."}),"\n",(0,i.jsxs)(e.p,{children:["This runs in ",(0,i.jsxs)(e.span,{className:"katex",children:[(0,i.jsx)(e.span,{className:"katex-mathml",children:(0,i.jsx)(e.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,i.jsxs)(e.semantics,{children:[(0,i.jsxs)(e.mrow,{children:[(0,i.jsx)(e.mi,{mathvariant:"script",children:"O"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"("}),(0,i.jsx)(e.mi,{children:"n"}),(0,i.jsx)(e.mo,{stretchy:"false",children:"!"}),(0,i.jsx)(e.mo,{stretchy:"false",children:")"})]}),(0,i.jsx)(e.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(n!)"})]})})}),(0,i.jsx)(e.span,{className:"katex-html","aria-hidden":"true",children:(0,i.jsxs)(e.span,{className:"base",children:[(0,i.jsx)(e.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,i.jsx)(e.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),(0,i.jsx)(e.span,{className:"mopen",children:"("}),(0,i.jsx)(e.span,{className:"mord mathnormal",children:"n"}),(0,i.jsx)(e.span,{className:"mclose",children:"!)"})]})})]})]}),"\n",(0,i.jsx)(e.h1,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)("div",{style:{transform:"translateX(150px)"},children:(0,i.jsx)(c.A,{language:"cpp",style:o.A,children:'#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <set> \n#include <map> \nusing namespace std;\n\nset<string> a; \nmap<char, int> v; \nstring z;\nvoid go(string cur) {\n  if(cur.size() == z.size()) { a.insert(cur); return; }\n  for(char c : z) {\n      if(v[c] > 0) {\n          v[c]--; \n          string ncur = cur + c; \n          go(ncur); \n          v[c]++; \n      }\n  }\n}\nint main() {\n  cin >> z; \n  for(char c : z) v[c]++; \n  go("");\n  cout << a.size() << endl;\n  for(string u : a) cout << u << endl;\n}\n'})})]})}function g(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(p,{...n})}):p(n)}}}]);