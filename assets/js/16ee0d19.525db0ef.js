"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8538],{4134:(s,n,e)=>{e.r(n),e.d(n,{assets:()=>h,contentTitle:()=>o,default:()=>g,frontMatter:()=>m,metadata:()=>i,moduleName:()=>d,toc:()=>p});const i=JSON.parse('{"id":"solutions/TVS2025/MushroomKingdom","title":"MushroomKingdom","description":"Tags: Maps, Sorting","source":"@site/docs/solutions/TVS2025/MushroomKingdom.mdx","sourceDirName":"solutions/TVS2025","slug":"/solutions/TVS2025/MushroomKingdom","permalink":"/SeaFarmers/docs/solutions/TVS2025/MushroomKingdom","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Mansion","permalink":"/SeaFarmers/docs/solutions/TVS2025/Mansion"},"next":{"title":"NowTHATsASuit","permalink":"/SeaFarmers/docs/solutions/TVS2025/NowTHATsASuit"}}');var a=e(4848),l=e(8453),t=(e(6540),e(2407),e(8092)),r=e(8866),c=e(426);const m={},o="The Mushroom Kingdom Solution",h={},d="LearnToCode",p=[];function x(s){const n={annotation:"annotation",h1:"h1",header:"header",math:"math",mi:"mi",mn:"mn",mo:"mo",mrow:"mrow",msub:"msub",p:"p",semantics:"semantics",span:"span",...(0,l.R)(),...s.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.A,{moduleName:d}),"\n",(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"the-mushroom-kingdom-solution",children:"The Mushroom Kingdom Solution"})}),"\n",(0,a.jsx)(n.p,{children:"Tags: Maps, Sorting"}),"\n",(0,a.jsx)(n.h1,{id:"subtask-with-randomness",children:"Subtask: With Randomness"}),"\n",(0,a.jsx)(n.p,{children:"If you maintain a 2-D array of all patches, you can simulate walking in a random direction, but since\nthe kingdom is so big, we can't quite to that. Instead, we can use a map to hold all patches of interest\nsince most patches are not interesting."}),"\n",(0,a.jsxs)(n.p,{children:["This has a upper-bound time of ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{mathvariant:"script",children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsxs)(n.msub,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"log"}),(0,a.jsx)(n.mo,{children:"\u2061"})]}),(0,a.jsx)(n.mn,{children:"2"})]}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"N"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"}),(0,a.jsx)(n.mo,{children:"\u2217"}),(0,a.jsx)(n.mi,{children:"N"}),(0,a.jsx)(n.mo,{children:"\u2217"}),(0,a.jsx)(n.mi,{children:"Q"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(\\log_2(N)*N*Q)"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsxs)(n.span,{className:"mop",children:[(0,a.jsxs)(n.span,{className:"mop",children:["lo",(0,a.jsx)(n.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.207em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.4559em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.2441em"},children:(0,a.jsx)(n.span,{})})})]})})]}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,a.jsx)(n.span,{className:"mclose",children:")"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"Q"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})]})]})," but with randomness, it is much less."]}),"\n",(0,a.jsx)(n.h1,{id:"simulation-with-map",children:"Simulation with Map"}),"\n",(0,a.jsx)("div",{style:{transform:"translateX(150px)"},children:(0,a.jsx)(r.A,{language:"cpp",style:c.A,children:'#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <map>\nusing namespace std;\n\nmap<pair<long long, long long>, int> patches; \nmap<pair<long long, long long>, pair<long long, long long>> nex[4]; \nvector<int> xc = {0, 1, 0, -1};\nvector<int> yc = {1, 0, -1, 0};\npair<long long, long long> go(pair<long long, long long> pos, int dir, int dis) {\n  pair<long long, long long> cur = {pos.first + xc[dir] * dis, pos.second + yc[dir] * dis};\n  if(!patches.count(cur)) return cur; \n  if(patches[cur] == 1) return pos; \n  return go(pos, dir, dis + 1);\n}\nint main() {\n  pair<long long, long long> pos; \n  int R, G, Q;\n  cin >> R >> G >> pos.first >> pos.second >> Q; \n  for(int i = 0; i < R; i++) {\n      long long x, y; \n      cin >> x >> y; \n      patches[{x, y}] = 1; \n  }\n  for(int i = 0; i < G; i++) {\n      long long x, y; \n      cin >> x >> y; \n      patches[{x, y}] = 2; \n  }\n  for(int i = 0; i < Q; i++) {\n      string z; \n      cin >> z; \n      int dir = 0; \n      if(z == "East") dir = 1; \n      else if(z == "South") dir = 2; \n      else if(z == "West") dir = 3;\n      pos = go(pos, dir, 1); \n      cout << pos.first << " " << pos.second << endl;\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h1,{id:"full-breakdown",children:"Full Breakdown"}),"\n",(0,a.jsxs)(n.p,{children:["Since these test cases are not random, the omplexity could be ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{mathvariant:"script",children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsxs)(n.msub,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"log"}),(0,a.jsx)(n.mo,{children:"\u2061"})]}),(0,a.jsx)(n.mn,{children:"2"})]}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"N"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"}),(0,a.jsx)(n.mo,{children:"\u2217"}),(0,a.jsx)(n.mi,{children:"N"}),(0,a.jsx)(n.mo,{children:"\u2217"}),(0,a.jsx)(n.mi,{children:"Q"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(\\log_2(N)*N*Q)"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsxs)(n.span,{className:"mop",children:[(0,a.jsxs)(n.span,{className:"mop",children:["lo",(0,a.jsx)(n.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.207em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.4559em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.2441em"},children:(0,a.jsx)(n.span,{})})})]})})]}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,a.jsx)(n.span,{className:"mclose",children:")"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"Q"}),(0,a.jsx)(n.span,{className:"mclose",children:")"})]})]})]}),", infact it is.\nSo, we have to take a different approach."]}),"\n",(0,a.jsxs)(n.p,{children:["If we pre-compute where a patches will take us, we only have to compute ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsx)(n.mrow,{children:(0,a.jsx)(n.mi,{children:"N"})}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"N"})]})})}),(0,a.jsx)(n.span,{className:"katex-html","aria-hidden":"true",children:(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"0.6833em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"})]})})]}),' patches because most patches are\nnot special. Thus, if we sort based on all directions and "walk" from one end of slipery patches to the other,\nwe can store the results in a map.']}),"\n",(0,a.jsx)(n.p,{children:'You could also "memorize" whenever you first calculate a position, but this is simpler imo.'}),"\n",(0,a.jsxs)(n.p,{children:["The complexity is ",(0,a.jsxs)(n.span,{className:"katex",children:[(0,a.jsx)(n.span,{className:"katex-mathml",children:(0,a.jsx)(n.math,{xmlns:"http://www.w3.org/1998/Math/MathML",children:(0,a.jsxs)(n.semantics,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{mathvariant:"script",children:"O"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsxs)(n.msub,{children:[(0,a.jsxs)(n.mrow,{children:[(0,a.jsx)(n.mi,{children:"log"}),(0,a.jsx)(n.mo,{children:"\u2061"})]}),(0,a.jsx)(n.mn,{children:"2"})]}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"N"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"}),(0,a.jsx)(n.mo,{children:"\u2217"}),(0,a.jsx)(n.mo,{stretchy:"false",children:"("}),(0,a.jsx)(n.mi,{children:"N"}),(0,a.jsx)(n.mo,{children:"+"}),(0,a.jsx)(n.mi,{children:"Q"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"}),(0,a.jsx)(n.mo,{stretchy:"false",children:")"})]}),(0,a.jsx)(n.annotation,{encoding:"application/x-tex",children:"\\mathcal{O}(\\log_2(N)*(N+Q))"})]})})}),(0,a.jsxs)(n.span,{className:"katex-html","aria-hidden":"true",children:[(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathcal",style:{marginRight:"0.02778em"},children:"O"}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsxs)(n.span,{className:"mop",children:[(0,a.jsxs)(n.span,{className:"mop",children:["lo",(0,a.jsx)(n.span,{style:{marginRight:"0.01389em"},children:"g"})]}),(0,a.jsx)(n.span,{className:"msupsub",children:(0,a.jsxs)(n.span,{className:"vlist-t vlist-t2",children:[(0,a.jsxs)(n.span,{className:"vlist-r",children:[(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.207em"},children:(0,a.jsxs)(n.span,{style:{top:"-2.4559em",marginRight:"0.05em"},children:[(0,a.jsx)(n.span,{className:"pstrut",style:{height:"2.7em"}}),(0,a.jsx)(n.span,{className:"sizing reset-size6 size3 mtight",children:(0,a.jsx)(n.span,{className:"mord mtight",children:"2"})})]})}),(0,a.jsx)(n.span,{className:"vlist-s",children:"\u200b"})]}),(0,a.jsx)(n.span,{className:"vlist-r",children:(0,a.jsx)(n.span,{className:"vlist",style:{height:"0.2441em"},children:(0,a.jsx)(n.span,{})})})]})})]}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,a.jsx)(n.span,{className:"mclose",children:")"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"\u2217"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mopen",children:"("}),(0,a.jsx)(n.span,{className:"mord mathnormal",style:{marginRight:"0.10903em"},children:"N"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}}),(0,a.jsx)(n.span,{className:"mbin",children:"+"}),(0,a.jsx)(n.span,{className:"mspace",style:{marginRight:"0.2222em"}})]}),(0,a.jsxs)(n.span,{className:"base",children:[(0,a.jsx)(n.span,{className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,a.jsx)(n.span,{className:"mord mathnormal",children:"Q"}),(0,a.jsx)(n.span,{className:"mclose",children:"))"})]})]})]})]}),"\n",(0,a.jsx)(n.h1,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)("div",{style:{transform:"translateX(150px)"},children:(0,a.jsx)(r.A,{language:"cpp",style:c.A,children:'#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <map>\nusing namespace std;\n\nmap<pair<long long, long long>, int> patches; \nmap<pair<long long, long long>, pair<long long, long long>> nex[4]; \nvector<int> xc = {0, 1, 0, -1};\nvector<int> yc = {1, 0, -1, 0};\npair<long long, long long> go(pair<long long, long long> pos, int dir) {\n  return {pos.first + xc[dir], pos.second + yc[dir]}; \n}\nint main() {\n  pair<long long, long long> pos; \n  int R, G, Q;\n  cin >> R >> G >> pos.first >> pos.second >> Q; \n  for(int i = 0; i < R; i++) {\n      long long x, y; \n      cin >> x >> y; \n      patches[{x, y}] = 1; \n  }\n  vector<pair<long long, long long>> slip; \n  for(int i = 0; i < G; i++) {\n      long long x, y; \n      cin >> x >> y; \n      slip.push_back({x, y}); \n      patches[{x, y}] = 2; \n  }\n  sort(slip.begin(), slip.end(), [](auto a, auto b){ \n      if(a.first == b.first) return a.second < b.second; \n      return a.first < b.first; \n  });\n  for(int i = 0; i < slip.size(); i++) {\n      int r = i; \n      while(r + 1 < slip.size() && slip[i].first == slip[r + 1].first \n          && slip[r].second + 1 == slip[r + 1].second) r++; \n      nex[0][slip[i]] = go(slip[r], 0); \n      i = r; \n  }\n  sort(slip.begin(), slip.end(), [](auto a, auto b){ \n      if(a.first == b.first) return a.second > b.second; \n      return a.first < b.first; \n  });\n  for(int i = 0; i < slip.size(); i++) {\n      int r = i; \n      while(r + 1 < slip.size() && slip[i].first == slip[r + 1].first \n          && slip[r].second - 1 == slip[r + 1].second) r++; \n      nex[2][slip[i]] = go(slip[r], 2); \n      i = r; \n  }\n  sort(slip.begin(), slip.end(), [](auto a, auto b){ \n      if(a.second == b.second) return a.first < b.first; \n      return a.second < b.second; \n  });\n  for(int i = 0; i < slip.size(); i++) {\n      int r = i; \n      while(r + 1 < slip.size() && slip[i].second == slip[r + 1].second \n          && slip[r].first + 1 == slip[r + 1].first) r++; \n      nex[1][slip[i]] = go(slip[r], 1); \n      i = r; \n  }\n  sort(slip.begin(), slip.end(), [](auto a, auto b){ \n      if(a.second == b.second) return a.first > b.first; \n      return a.second < b.second; \n  });\n  for(int i = 0; i < slip.size(); i++) {\n      int r = i; \n      while(r + 1 < slip.size() && slip[i].second == slip[r + 1].second \n          && slip[r].first - 1 == slip[r + 1].first) r++; \n      nex[3][slip[i]] = go(slip[r], 3); \n      i = r; \n  }\n  for(int i = 0; i < Q; i++) {\n      string z; \n      cin >> z; \n      int dir = 0; \n      if(z == "East") dir = 1; \n      else if(z == "South") dir = 2; \n      else if(z == "West") dir = 3;\n      pair<long long, long long> cur = go(pos, dir); \n      if(!nex[dir].count(cur) && patches[cur] != 1) pos = cur; \n      else if(nex[dir].count(cur) && patches[nex[dir][cur]] != 1) pos = nex[dir][cur];\n      cout << pos.first << " " << pos.second << endl;\n  }\n}\n'})})]})}function g(s={}){const{wrapper:n}={...(0,l.R)(),...s.components};return n?(0,a.jsx)(n,{...s,children:(0,a.jsx)(x,{...s})}):x(s)}}}]);